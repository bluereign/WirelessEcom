<!--- COMPONENT --->
<cfcomponent displayname="ReachListService" output="false" hint="I am the ReachListService class.">

<!--- INIT --->
<cffunction name="init" access="public" output="false" returntype="any" hint="I am the constructor method of the ReachListService class.">
  <cfset variables.datasource = application.dsn.wirelessadvocates />
  <cfreturn this>
</cffunction>

<!--- PUBLIC METHODS --->
<!--- CREATE --->
<cffunction name="createNewReachList" access="public" output="false" returntype="numeric" hint="I insert a new reachList record into the campaign.SmsReachList table in the database.">
  <cfargument name="reachList" type="any" required="true" hint="I am the ReachList bean." />
  <cfset var qPutReachList = '' />
  <cfset var insertResult = '' />
  <cftry>
  <cfquery name="qPutReachList" datasource="#variables.datasource#" result="insertResult">
  	INSERT INTO campaign.SmsReachList
  		(
  		  country,
  		  carrierId,
  		  shortName,
        longName,
        aka
  		) VALUES (
  		  <cfqueryparam value="#ARGUMENTS.reachList.getCountry()#" cfsqltype="cf_sql_varchar" />,
  		  <cfqueryparam value="#ARGUMENTS.reachList.getCarrierId()#" cfsqltype="cf_sql_integer" />,
  		  <cfqueryparam value="#ARGUMENTS.reachList.getShortName()#" cfsqltype="cf_sql_varchar" />,
        <cfqueryparam value="#ARGUMENTS.reachList.getLongName()#" cfsqltype="cf_sql_varchar" />,
        <cfqueryparam value="#ARGUMENTS.reachList.getAka()#" cfsqltype="cf_sql_varchar" />
  		)
  </cfquery>
  <!--- catch any errors --->
  <cfcatch type="any">
  	<cfreturn 0 />
  </cfcatch>
  </cftry>
  <!--- return the id generated by the database (SQL Server) --->
  <cfreturn insertResult.IDENTITYCOL />
</cffunction>

<!--- RETRIEVE - BY ID --->
<cffunction name="getReachListByID" access="public" output="false" returntype="any" hint="I return a ReachList bean populated with the details of a specific reachList record.">
  <cfargument name="id" type="numeric" required="true" hint="I am the numeric auto-increment id of the reachList to search for." />
  <cfset var qGetReachList = '' />
  <cftry>

    <!--- get the reachList by uniqueId --->
    <cfquery name="qGetReachList" datasource="#variables.datasource#">
    	SELECT uniqueId, country, carrierId, shortName, longName, aka
    	FROM campaign.SmsReachList
    	WHERE uniqueId = <cfqueryparam value="#ARGUMENTS.id#" cfsqltype="cf_sql_integer" />
    </cfquery>

  <!--- catch any errors --->
  <cfcatch type="any">
  	<cfreturn createObject('component','cfc.model.system.sms.ReachList').init() />
  </cfcatch>
  </cftry>

  <!--- check if a reachList was found --->
  <cfif qGetReachList.RecordCount>
    <!--- it was, return a reachList bean --->
    <cfreturn createObject('component','cfc.model.system.sms.ReachList').init(
    	uniqueId    = qGetReachList.uniqueId,
    	country 	  = qGetReachList.country,
    	carrierId   = qGetReachList.carrierId,
    	shortName	  = qGetReachList.shortName,
      longName    = qGetReachList.longName,
      aka         = qGetReachList.aka
    ) />  
  <cfelse>
    <!--- return an empty bean --->
    <cfreturn createObject('component','cfc.model.system.sms.ReachList').init() />
  </cfif>
</cffunction>

<!--- RETEIVE - BY COUNTRY AND LONG NAME --->
<cffunction name="getReachListByCountryAndLongName" access="public" output="false" returntype="any" hint="I return a ReachList bean populated with the details of a specific reachList record.">
  <cfargument name="country" type="string" required="false" default="us" hint="I am the string country of the reachList to search for." />
  <cfargument name="longName" type="string" required="true" hint="I am the string long name of the reachList to search for." />
  <cfset var qGetReachList = '' />
  <cftry>

    <!--- get the reachList by country and long name --->
    <cfquery name="qGetReachList" datasource="#variables.datasource#">
      SELECT uniqueId, country, carrierId, shortName, longName, aka
      FROM campaign.SmsReachList
      WHERE country = <cfqueryparam value="#ARGUMENTS.country#" cfsqltype="cf_sql_varchar" />
      AND longName = <cfqueryparam value="#ARGUMENTS.longName#" cfsqltype="cf_sql_varchar" />
    </cfquery>

  <!--- catch any errors --->
  <cfcatch type="any">
    <cfreturn createObject('component','cfc.model.system.sms.ReachList').init() />
  </cfcatch>
  </cftry>

  <!--- check if a reachList was found --->
  <cfif qGetReachList.RecordCount>
    <!--- it was, return a reachList bean --->
    <cfreturn createObject('component','cfc.model.system.sms.ReachList').init(
      uniqueId    = qGetReachList.uniqueId,
      country     = qGetReachList.country,
      carrierId   = qGetReachList.carrierId,
      shortName   = qGetReachList.shortName,
      longName    = qGetReachList.longName,
      aka         = qGetReachList.aka
    ) />  
  <cfelse>
    <!--- return an empty bean --->
    <cfreturn createObject('component','cfc.model.system.sms.ReachList').init() />
  </cfif>
</cffunction>

<!--- UPDATE --->
<cffunction name="updateReachList" access="public" output="false" returntype="numeric" hint="I update this reachList record in the campaign.SmsReachList table of the database.">
  <cfargument name="reachList" type="any" required="true" hint="I am the ReachList bean." />
  <cfset var qUpdReachList = '' />
  <cftry>
    <cfquery name="qUpdReachList" datasource="#variables.datasource#">
    	UPDATE campaign.SmsReachList SET
    	  country = <cfqueryparam value="#ARGUMENTS.reachList.getCountry()#" cfsqltype="cf_sql_varchar" />,
    	  carrierId = <cfqueryparam value="#ARGUMENTS.reachList.getCarrierId()#" cfsqltype="cf_sql_integer" />,
    	  shortName = <cfqueryparam value="#ARGUMENTS.reachList.getShortName()#" cfsqltype="cf_sql_varchar" />,
        longName = <cfqueryparam value="#ARGUMENTS.reachList.getLongName()#" cfsqltype="cf_sql_varchar" />,
        aka = <cfqueryparam value="#ARGUMENTS.reachList.getAka()#" cfsqltype="cf_sql_varchar" />
    	WHERE uniqueId = <cfqueryparam value="#ARGUMENTS.reachList.getUniqueId()#" cfsqltype="cf_sql_integer" />
    </cfquery>
  <!--- catch any errors --->
  <cfcatch type="any">
  	<cfreturn 0 />
  </cfcatch>
  </cftry>
  <cfreturn ARGUMENTS.reachList.getUniqueId() />
</cffunction>

<!--- DELETE --->
<cffunction name="deleteReachListByID" access="public" output="false" returntype="boolean" hint="I delete a reachList from reachList table in the database.">
  <cfargument name="id" type="numeric" required="true" hint="I am the numeric auto-increment id of the reachList to delete." />
  <cfset var qDelReachList = '' />
  <cftry>
    <cfquery name="qDelReachList" datasource="#variables.datasource#">
  		DELETE FROM campaign.SmsReachList
  		WHERE uniqueId = <cfqueryparam value="#ARGUMENTS.id#" cfsqltype="cf_sql_integer" />
	  </cfquery>
  <cfcatch type="database">
    <cfreturn false />
  </cfcatch>
  </cftry>
  <cfreturn true />
</cffunction>

<!--- NO FILTER - GET ALL RECORDS --->
<cffunction name="getAllReachLists" access="public" output="false" returntype="query" hint="I return a query of all records in the campaign.SmsReachList table in the database.">
  <cfargument name="cache" type="any" required="false" default="false" hint="I am a flag to determine if this query should be cached." />
  <cfargument name="cacheTime" type="any" required="false" default="#CreateTimeSpan(0,1,0,0)#" hint="I am timespan to cache this query (Use CreateTimeSpan() or use the default cache time of one hour by not passing this variable." />
 
    <cfset var thisFilter = {
      cache = ARGUMENTS.cache,
      cacheTime = ARGUMENTS.cacheTime
    } />

  <cfreturn filterAllReachLists(thisFilter) />
</cffunction>

<!--- FILTER --->
<cffunction name="filter" access="public" output="false" returntype="any" hint="I run a query of all records within the database table.">
  <cfargument name="country" type="any" required="false" default="" hint="I am the country string to return records for." />
  <cfargument name="carrierId" type="any" required="false" default="" hint="I am the carrierId date to return records for." />
  <cfargument name="shortName" type="any" required="false" default="" hint="I am the shortName date to return records for." />
  <cfargument name="longName" type="any" required="false" default="" hint="I am the longName string to return records for." />
  <cfargument name="aka" type="any" required="false" default="" hint="I am the aka string to return records for." />
  <cfargument name="orderBy" type="any" required="false" default="" hint="I am the column (and optional ordinal ASC or DESC) that records should be ordered by." />
  <cfargument name="cache" type="any" required="false" default="false" hint="I am a flag to determine if this query should be cached." />
  <cfargument name="cacheTime" type="any" required="false" default="#CreateTimeSpan(0,1,0,0)#" hint="I am timespan to cache this query (Use CreateTimeSpan() or use the default cache time of one hour by not passing this variable." />
  <cfargument name="useSearch" type="boolean" required="false" default="false" hint="I am a flag to determine if this query should use 'LIKE' to search for records." />
    <cfset var thisFilter = StructNew() />
    <cfif IsDefined('ARGUMENTS.country') AND ARGUMENTS.country NEQ "">
      <cfset thisFilter.country = ARGUMENTS.country />
    </cfif>
    <cfif IsDefined('ARGUMENTS.carrierId') AND ARGUMENTS.carrierId NEQ "">
      <cfset thisFilter.carrierId = ARGUMENTS.carrierId />
    </cfif>
    <cfif IsDefined('ARGUMENTS.shortName') AND ARGUMENTS.shortName NEQ "">
      <cfset thisFilter.shortName = ARGUMENTS.shortName />
    </cfif>
    <cfif IsDefined('ARGUMENTS.longName') AND ARGUMENTS.longName NEQ "">
      <cfset thisFilter.longName = ARGUMENTS.longName />
    </cfif>
    <cfif IsDefined('ARGUMENTS.aka') AND ARGUMENTS.aka NEQ "">
      <cfset thisFilter.aka = ARGUMENTS.aka />
    </cfif>
    <cfif IsDefined('ARGUMENTS.orderBy') AND ARGUMENTS.orderBy NEQ "">
      <cfset thisFilter.order_by = ARGUMENTS.orderBy />
    </cfif>
    <cfif IsDefined('ARGUMENTS.cache') AND ARGUMENTS.cache NEQ false>
      <cfset thisFilter.cache = ARGUMENTS.cache />
    </cfif>
    <cfif IsDefined('ARGUMENTS.cacheTime') AND ARGUMENTS.cacheTime NEQ "">
      <cfset thisFilter.cacheTime = ARGUMENTS.cacheTime />
    </cfif>
    <cfif IsDefined('ARGUMENTS.useSearch') AND ARGUMENTS.useSearch NEQ false>
      <cfset thisFilter.useSearch = ARGUMENTS.useSearch />
    </cfif>
  <cfif structKeyExists(thisFilter, 'cache') AND thisFilter.cache>
    <cfreturn cacheAllReachLists(thisFilter) />
  <cfelseif structKeyExists(thisFilter, 'useSearch') AND thisFilter.useSearch>
    <cfreturn searchAllReachLists(thisFiler) />
  <cfelse>
    <cfreturn filterAllReachLists(thisFilter) />
  </cfif>
</cffunction>

<!--- PRIVATE METHODS --->
<!--- QUERY - CACHE ALL --->
<cffunction name="cacheAllReachLists" access="private" output="false" returntype="any" hint="I run a query and will return all campaign.SmsReachList records. If a filter has been applied, I will refine results based on the filter.">
  <cfargument name="filter" type="struct" required="false" default="#StructNew()#" hint="I am a structure used to filter the query." />
  <cfset var cachedQueryName = Hash( SerializeJSON( filter ), 'SHA-256') />
  <cfquery name="#cachedQueryName#" datasource="#variables.datasource#" cachedwithin="#ARGUMENTS.filter.cacheTime#">
    SELECT uniqueId, country, carrierId, shortName, longName, aka
    FROM campaign.SmsReachList
    WHERE 1 = 1
  <cfif NOT structIsEmpty(ARGUMENTS.filter)>
    <!--- filter is applied --->
    <cfif structKeyExists(ARGUMENTS.filter, 'country')>
    AND country = <cfqueryparam value="#ARGUMENTS.filter.country#" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'carrierId')>
    AND carrierId = <cfqueryparam value="#ARGUMENTS.filter.carrierId#" cfsqltype="cf_sql_integer" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'shortName')>
    AND shortName = <cfqueryparam value="#ARGUMENTS.filter.shortName#" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'longName')>
    AND longName = <cfqueryparam value="#ARGUMENTS.filter.longName#" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'aka')>
    AND aka = <cfqueryparam value="#ARGUMENTS.filter.aka#" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'order_by')>
    ORDER BY #ARGUMENTS.filter.order_by#
    </cfif>
  </cfif>
  </cfquery>
  <cfreturn variables[cachedQueryName] />
</cffunction>

<!--- QUERY - FILTER ALL --->
<cffunction name="filterAllReachLists" access="private" output="false" returntype="any" hint="I run a query and will return all campaign.SmsReachList records. If a filter has been applied, I will refine results based on the filter.">
  <cfargument name="filter" type="struct" required="false" default="#StructNew()#" hint="I am a structure used to filter the query." />
  <cfset var qGetReachLists = '' />
  <cfquery name="qGetReachLists" datasource="#variables.datasource#">
    SELECT uniqueId, country, carrierId, shortName, longName, aka
    FROM campaign.SmsReachList
    WHERE 1 = 1
  <cfif NOT structIsEmpty(ARGUMENTS.filter)>
    <!--- filter is applied --->
    <cfif structKeyExists(ARGUMENTS.filter, 'country')>
    AND country = <cfqueryparam value="#ARGUMENTS.filter.country#" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'carrierId')>
    AND carrierId = <cfqueryparam value="#ARGUMENTS.filter.carrierId#" cfsqltype="cf_sql_integer" />
    </cfif>    
    <cfif structKeyExists(ARGUMENTS.filter, 'shortName')>
    AND shortName = <cfqueryparam value="#ARGUMENTS.filter.shortName#" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'longName')>
    AND longName = <cfqueryparam value="#ARGUMENTS.filter.longName#" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'aka')>
    AND aka = <cfqueryparam value="#ARGUMENTS.filter.aka#" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'order_by')>
    ORDER BY #ARGUMENTS.filter.order_by#
    </cfif>
  </cfif>
  </cfquery>
  <cfreturn qGetReachLists />
</cffunction>

<!--- QUERY - SEARCH ALL --->
<cffunction name="searchAllReachLists" access="private" output="false" returntype="any" hint="I run a query and will return all campaign.SmsReachList records. If a filter has been applied, I will refine results based on the filter.">
  <cfargument name="filter" type="struct" required="false" default="#StructNew()#" hint="I am a structure used to filter the query." />
  <cfset var qGetReachLists = '' />
  <cfquery name="qGetReachLists" datasource="#variables.datasource#">
    SELECT uniqueId, country, carrierId, shortName, longName, aka
    FROM campaign.SmsReachList
    WHERE 1 = 1
  <cfif NOT structIsEmpty(ARGUMENTS.filter)>
    <!--- filter is applied --->
    <cfif structKeyExists(ARGUMENTS.filter, 'country')>
    AND country LIKE <cfqueryparam value="%#ARGUMENTS.filter.country#%" cfsqltype="cf_sql_varchar" />
    </cfif>  
    <cfif structKeyExists(ARGUMENTS.filter, 'carrierId')>
    AND carrierId LIKE <cfqueryparam value="%#ARGUMENTS.filter.carrierId#%" cfsqltype="cf_sql_integer" />
    </cfif>   
    <cfif structKeyExists(ARGUMENTS.filter, 'shortName')>
    AND shortName LIKE <cfqueryparam value="%#ARGUMENTS.filter.shortName#%" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'longName')>
    AND longName LIKE <cfqueryparam value="%#ARGUMENTS.filter.longName#%" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'aka')>
    AND aka LIKE <cfqueryparam value="%#ARGUMENTS.filter.aka#%" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'order_by')>
    ORDER BY #ARGUMENTS.filter.order_by#
    </cfif>
  </cfif>
  </cfquery>
  <cfreturn qGetReachLists />
</cffunction>

<!--- UTILITY FUNCTIONS --->
<!--- SAVE --->
<cffunction name="saveReachList" access="public" output="false" returntype="any" hint="I handle saving a reachList either by creating a new entry or updating an existing one.">
  <cfargument name="reachList" type="any" required="true" hint="I am the ReachList bean." />
  <cfif exists(ARGUMENTS.reachList)>
  	<cfreturn updateReachList(ARGUMENTS.reachList) />
  <cfelse>
  	<cfreturn createNewReachList(ARGUMENTS.reachList) />
  </cfif>
</cffunction>

<!--- EXISTS --->
<cffunction name="exists" access="private" output="false" returntype="boolean" hint="I check to see if a specific ReachList is in the database, using ID as the check.">
  <cfargument name="reachList" type="any" required="true" hint="I am the ReachList bean." />
  <cfset var qGetReachList = '' />
  <cfquery name="qGetReachList" datasource="#variables.datasource#">
  	SELECT uniqueId FROM campaign.SmsReachList
  	WHERE uniqueId = <cfqueryparam value="#ARGUMENTS.reachList.getUniqueId()#" cfsqltype="cf_sql_integer" />
  </cfquery>
  <cfif qGetReachList.RecordCount>
	 <cfreturn true />
  <cfelse>
	 <cfreturn false />
  </cfif>
</cffunction>

</cfcomponent>

