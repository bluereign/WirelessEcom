<!--- COMPONENT --->
<cfcomponent displayname="UserService" output="false" hint="I am the UserService class.">

<!--- INIT --->
<cffunction name="init" access="public" output="false" returntype="any" hint="I am the constructor method of the UserService class.">
  <cfset variables.utils = CreateObject('component','model.utils').init() />
  <cfset variables.datasource = application.getApplicationSettings().datasource />
  <cfreturn this>
</cffunction>

<!--- PUBLIC METHODS --->
<!--- CREATE --->
<cffunction name="createNewUser" access="public" output="false" returntype="numeric" hint="I insert a new user record into the mtUsers table in the database.">
  <cfargument name="user" type="any" required="true" hint="I am the User bean." />
  <cfset var qPutUser = '' />
  <cfset var insertResult = '' />
  <cftry>
  <cfquery name="qPutUser" datasource="#variables.datasource#" result="insertResult">
  	INSERT INTO merchtool.[User]
  		(
  		  username,
  		  password,
  		  roles,
  		  isActive
  		) VALUES (
  		  <cfqueryparam value="#variables.utils.dataEnc(ARGUMENTS.user.getUsername(), 'repeatable')#" cfsqltype="cf_sql_varchar" />,
  		  <cfqueryparam value="#variables.utils.dataEnc(ARGUMENTS.user.getPassword(), 'db')#" cfsqltype="cf_sql_varchar" />,
  		  <cfqueryparam value="#ARGUMENTS.user.getRoles()#" cfsqltype="cf_sql_varchar" />,
  		  <cfqueryparam value="#ARGUMENTS.user.getIsActive()#" cfsqltype="cf_sql_bit" />
  		)
  </cfquery>
  <!--- catch any errors --->
  <cfcatch type="any">
  	<cfset variables.utils.errorHandler(cfcatch) />
  	<cfreturn 0 />
  </cfcatch>
  </cftry>
  <!--- return the id generated by the database (SQL Server) --->
  <cfreturn insertResult.IDENTITYCOL />
</cffunction>

<!--- RETRIEVE - BY ID --->
<cffunction name="getUserByID" access="public" output="false" returntype="any" hint="I return a User bean populated with the details of a specific user record.">
  <cfargument name="id" type="numeric" required="true" hint="I am the numeric auto-increment id of the user to search for." />
  <cfset var qGetUser = '' />
  <cfset var userObject = '' />
  <cfset var formFields = '' />
  <cfset var iX = 0 />
  <cftry>

    <!--- get the user by userId --->
    <cfquery name="qGetUser" datasource="#variables.datasource#">
    	SELECT userId, username, password, roless, isActive
    	FROM merchtool.[User]
    	WHERE userId = <cfqueryparam value="#ARGUMENTS.id#" cfsqltype="cf_sql_integer" />
    </cfquery>

  <!--- catch any errors --->
  <cfcatch type="any">
  	<cfset variables.utils.errorHandler(cfcatch) />
  	<cfreturn createObject('component','model.User').init() />
  </cfcatch>
  </cftry>

  <!--- check if a user was found --->
  <cfif qGetUser.RecordCount>
    <!--- it was, return a user bean --->
    <cfreturn createObject('component','model.User').init(
    	userId       = qGetUser.userId,
    	username 	   = variables.utils.dataDec(qGetUser.username, 'repeatable'),
    	password     = variables.utils.dataDec(qGetUser.password, 'db'),
    	roles	       = qGetUser.roles,
    	isActive     = qGetUser.isActive
    ) />  
  <cfelse>
    <!--- return an empty bean --->
    <cfreturn createObject('component','model.User').init() />
  </cfif>
</cffunction>

<!--- RETRIEVE - BY USERNAME --->
<cffunction name="getUserByUsername" access="public" output="false" returntype="any" hint="I return a User bean populated with the details of a specific user record.">
  <cfargument name="username" type="string" required="true" hint="I am the email address of the user to search for." />
  <cfset var qGetUser = '' />
  <cfset var userObject = '' />
  <cftry>
  <cfquery name="qGetUser" datasource="#variables.datasource#">
    SELECT userId, username, password, roles, isActive
    FROM merchtool.[User]
    WHERE username = <cfqueryparam value="#variables.utils.dataEnc(ARGUMENTS.username, 'repeatable')#" cfsqltype="cf_sql_varchar" />
  </cfquery>
  <!--- catch any errors --->
  <cfcatch type="any">
  <cfset variables.utils.errorHandler(cfcatch) />
  <cfreturn createObject('component','model.User').init() />
  </cfcatch>
  </cftry>
  <cfif qGetUser.RecordCount>
    <cfreturn createObject('component','model.User').init(
      userId    = qGetUser.userId,
      username  = variables.utils.dataDec(qGetUser.username, 'repeatable'),
      password  = variables.utils.dataDec(qGetUser.password),
      roles     = qGetUser.roles,
      isActive  = qGetUser.isActive
    ) />
  <cfelse>
    <cfreturn createObject('component','model.User').init() />
  </cfif>
</cffunction>

<!--- UPDATE --->
<cffunction name="updateUser" access="public" output="false" returntype="numeric" hint="I update this user record in the mtUsers table of the database.">
  <cfargument name="user" type="any" required="true" hint="I am the User bean." />
  <cfset var qUpdUser = '' />
  <cftry>
    <cfquery name="qUpdUser" datasource="#variables.datasource#">
    	UPDATE merchtool.[User] 
		SET
    	  username = <cfqueryparam value="#variables.utils.dataEnc(ARGUMENTS.user.getUsername(), 'repeatable')#" cfsqltype="cf_sql_varchar" />,
    	  password = <cfqueryparam value="#variables.utils.dataEnc(ARGUMENTS.user.getPassword(), 'db')#" cfsqltype="cf_sql_varchar" />,
    	  roles = <cfqueryparam value="#ARGUMENTS.user.getRoles()#" cfsqltype="cf_sql_varchar" />,
    	  isActive = <cfqueryparam value="#ARGUMENTS.user.getIsActive()#" cfsqltype="cf_sql_bit" />
    	WHERE userId = <cfqueryparam value="#ARGUMENTS.user.getUserId()#" cfsqltype="cf_sql_integer" />
    </cfquery>
  <!--- catch any errors --->
  <cfcatch type="any">
  	<cfset variables.utils.errorHandler(cfcatch) />
  	<cfreturn 0 />
  </cfcatch>
  </cftry>
  <cfreturn ARGUMENTS.user.getUserId() />
</cffunction>

<!--- DELETE --->
<cffunction name="deleteUserByID" access="public" output="false" returntype="boolean" hint="I delete a user from user table in the database.">
  <cfargument name="id" type="numeric" required="true" hint="I am the numeric auto-increment id of the user to delete." />
  <cfset var qDelUser = '' />
  <cftry>
    <cfquery name="qDelUser" datasource="#variables.datasource#">
  		DELETE FROM merchtool.[User]
  		WHERE userId = <cfqueryparam value="#ARGUMENTS.id#" cfsqltype="cf_sql_integer" />
	  </cfquery>
  <cfcatch type="database">
    <cfreturn false />
  </cfcatch>
  </cftry>
  <cfreturn true />
</cffunction>


<!--- CHECK IF USER EXISTS --->
<cffunction name="checkIfUserExists" access="public" returntype="boolean" output="false" hint="I check to see if a specific user is in the database, using their username address as the check.">
  <cfargument name="username" type="string" required="true" hint="I am the username address to check for the existence of." />
  <cfset var qGetUser = '' />
  <cfquery name="qGetUser" datasource="#variables.datasource#">
    SELECT userId FROM merchtool.[User]
    WHERE username = <cfqueryparam value="#variables.utils.dataEnc(ARGUMENTS.username, 'repeatable')#" cfsqltype="cf_sql_varchar" />
  </cfquery>
  <cfif qGetUser.RecordCount>
    <cfreturn true />
  <cfelse>
    <cfreturn false />
  </cfif>
</cffunction>

<!--- NO FILTER - GET ALL RECORDS --->
<cffunction name="getAllUsers" access="public" output="false" returntype="query" hint="I return a query of all records in the mtUsers table in the database.">
  <cfargument name="cache" type="any" required="false" default="false" hint="I am a flag to determine if this query should be cached." />
  <cfargument name="cacheTime" type="any" required="false" default="#CreateTimeSpan(0,1,0,0)#" hint="I am timespan to cache this query (Use CreateTimeSpan() or use the default cache time of one hour by not passing this variable." />
 
    <cfset var thisFilter = {
      cache = ARGUMENTS.cache,
      cacheTime = ARGUMENTS.cacheTime
    } />

  <cfreturn filterAllUsers(thisFilter) />
</cffunction>

<!--- FILTER --->
<cffunction name="filter" access="public" output="false" returntype="any" hint="I run a query of all records within the database table.">
  <cfargument name="username" type="any" required="false" default="" hint="I am the username string to return records for." />
  <cfargument name="password" type="any" required="false" default="" hint="I am the password date to return records for." />
  <cfargument name="roles" type="any" required="false" default="" hint="I am the roles date to return records for." />
  <cfargument name="isActive" type="any" required="false" default="" hint="I am the isActive boolean to return records for." />
  <cfargument name="orderBy" type="any" required="false" default="" hint="I am the column (and optional ordinal ASC or DESC) that records should be ordered by." />
  <cfargument name="cache" type="any" required="false" default="false" hint="I am a flag to determine if this query should be cached." />
  <cfargument name="cacheTime" type="any" required="false" default="#CreateTimeSpan(0,1,0,0)#" hint="I am timespan to cache this query (Use CreateTimeSpan() or use the default cache time of one hour by not passing this variable." />
  <cfargument name="useSearch" type="boolean" required="false" default="false" hint="I am a flag to determine if this query should use 'LIKE' to search for records." />
    <cfset var thisFilter = StructNew() />
    <cfif IsDefined('ARGUMENTS.username') AND ARGUMENTS.username NEQ "">
      <cfset thisFilter.username = variables.utils.dataEnc(ARGUMENTS.username, 'repeatable') />
    </cfif>
    <cfif IsDefined('ARGUMENTS.password') AND ARGUMENTS.password NEQ "">
      <cfset thisFilter.password = variables.utils.dataEnc(ARGUMENTS.password, 'db') />
    </cfif>
    <cfif IsDefined('ARGUMENTS.roles') AND ARGUMENTS.roles NEQ "">
      <cfset thisFilter.roles = ARGUMENTS.roles />
    </cfif>
    <cfif IsDefined('ARGUMENTS.isActive') AND ARGUMENTS.isActive NEQ "">
      <cfset thisFilter.isActive = ARGUMENTS.isActive />
    </cfif>
    <cfif IsDefined('ARGUMENTS.orderBy') AND ARGUMENTS.orderBy NEQ "">
      <cfset thisFilter.order_by = ARGUMENTS.orderBy />
    </cfif>
    <cfif IsDefined('ARGUMENTS.cache') AND ARGUMENTS.cache NEQ false>
      <cfset thisFilter.cache = ARGUMENTS.cache />
    </cfif>
    <cfif IsDefined('ARGUMENTS.cacheTime') AND ARGUMENTS.cacheTime NEQ "">
      <cfset thisFilter.cacheTime = ARGUMENTS.cacheTime />
    </cfif>
    <cfif IsDefined('ARGUMENTS.useSearch') AND ARGUMENTS.useSearch NEQ false>
      <cfset thisFilter.useSearch = ARGUMENTS.useSearch />
    </cfif>
  <cfif structKeyExists(thisFilter, 'cache') AND thisFilter.cache>
    <cfreturn cacheAllUsers(thisFilter) />
  <cfelseif structKeyExists(thisFilter, 'useSearch') AND thisFilter.useSearch>
    <cfreturn searchAllUsers(thisFiler) />
  <cfelse>
    <cfreturn filterAllUsers(thisFilter) />
  </cfif>
</cffunction>

<!--- PRIVATE METHODS --->
<!--- QUERY - CACHE ALL --->
<cffunction name="cacheAllUsers" access="private" output="false" returntype="any" hint="I run a query and will return all mtUsers records. If a filter has been applied, I will refine results based on the filter.">
  <cfargument name="filter" type="struct" required="false" default="#StructNew()#" hint="I am a structure used to filter the query." />
  <cfset var cachedQueryName = '' />
  <cfset cachedQueryName = Hash( SerializeJSON( filter ), 'SHA-256') />
  <cfquery name="#cachedQueryName#" datasource="#variables.datasource#" cachedwithin="#ARGUMENTS.filter.cacheTime#">
    SELECT userId, username, password, roless, isActive
    FROM merchtool.[User]
    WHERE 1 = 1
  <cfif NOT structIsEmpty(ARGUMENTS.filter)>
    <!--- filter is applied --->
    <cfif structKeyExists(ARGUMENTS.filter, 'username')>
    AND username = <cfqueryparam value="#ARGUMENTS.filter.username#" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'password')>
    AND password = <cfqueryparam value="#ARGUMENTS.filter.password#" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'roles')>
    AND roles = <cfqueryparam value="#ARGUMENTS.filter.roles#" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'isActive')>
    AND isActive = <cfqueryparam value="#ARGUMENTS.filter.isActive#" cfsqltype="cf_sql_bit" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'order_by')>
    ORDER BY #ARGUMENTS.filter.order_by#
    </cfif>
  </cfif>
  </cfquery>
  <cfreturn variables[cachedQueryName] />
</cffunction>

<!--- QUERY - FILTER ALL --->
<cffunction name="filterAllUsers" access="private" output="false" returntype="any" hint="I run a query and will return all mtUsers records. If a filter has been applied, I will refine results based on the filter.">
  <cfargument name="filter" type="struct" required="false" default="#StructNew()#" hint="I am a structure used to filter the query." />
  <cfset var qGetUsers = '' />
  <cfquery name="qGetUsers" datasource="#variables.datasource#">
    SELECT userId, username, password, roless, isActive
    FROM merchtool.[User]
    WHERE 1 = 1
  <cfif NOT structIsEmpty(ARGUMENTS.filter)>
    <!--- filter is applied --->
    <cfif structKeyExists(ARGUMENTS.filter, 'username')>
    AND username = <cfqueryparam value="#ARGUMENTS.filter.username#" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'password')>
    AND password = <cfqueryparam value="#ARGUMENTS.filter.password#" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'roles')>
    AND roles = <cfqueryparam value="#ARGUMENTS.filter.roles#" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'isActive')>
    AND isActive = <cfqueryparam value="#ARGUMENTS.filter.isActive#" cfsqltype="cf_sql_bit" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'order_by')>
    ORDER BY #ARGUMENTS.filter.order_by#
    </cfif>
  </cfif>
  </cfquery>
  <cfreturn qGetUsers />
</cffunction>

<!--- QUERY - SEARCH ALL --->
<cffunction name="searchAllUsers" access="private" output="false" returntype="any" hint="I run a query and will return all mtUsers records. If a filter has been applied, I will refine results based on the filter.">
  <cfargument name="filter" type="struct" required="false" default="#StructNew()#" hint="I am a structure used to filter the query." />
  <cfset var qGetUsers = '' />
  <cfquery name="qGetUsers" datasource="#variables.datasource#">
    SELECT userId, username, password, roless, smsMessage, isActive
    FROM merchtool.[User]
    WHERE 1 = 1
  <cfif NOT structIsEmpty(ARGUMENTS.filter)>
    <!--- filter is applied --->
    <cfif structKeyExists(ARGUMENTS.filter, 'username')>
    AND username LIKE <cfqueryparam value="%#ARGUMENTS.filter.username#%" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'password')>
    AND password LIKE <cfqueryparam value="%#ARGUMENTS.filter.password#%" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'roles')>
    AND roles LIKE <cfqueryparam value="%#ARGUMENTS.filter.roles#%" cfsqltype="cf_sql_varchar" />
    </cfif>
    <cfif structKeyExists(ARGUMENTS.filter, 'order_by')>
    ORDER BY #ARGUMENTS.filter.order_by#
    </cfif>
  </cfif>
  </cfquery>
  <cfreturn qGetUsers />
</cffunction>

<!--- UTILITY FUNCTIONS --->
<!--- SAVE --->
<cffunction name="saveUser" access="public" output="false" returntype="any" hint="I handle saving a user either by creating a new entry or updating an existing one.">
  <cfargument name="user" type="any" required="true" hint="I am the User bean." />
  <cfif exists(ARGUMENTS.user)>
  	<cfreturn updateUser(ARGUMENTS.user) />
  <cfelse>
  	<cfreturn createNewUser(ARGUMENTS.user) />
  </cfif>
</cffunction>

<!--- EXISTS --->
<cffunction name="exists" access="private" output="false" returntype="boolean" hint="I check to see if a specific User is in the database, using ID as the check.">
  <cfargument name="user" type="any" required="true" hint="I am the User bean." />
  <cfset var qGetUser = '' />
  <cfquery name="qGetUser" datasource="#variables.datasource#">
  	SELECT userId FROM merchtool.[User]
  	WHERE userId = <cfqueryparam value="#ARGUMENTS.user.getUserId()#" cfsqltype="cf_sql_integer" />
  </cfquery>
  <cfif qGetUser.RecordCount>
	 <cfreturn true />
  <cfelse>
	 <cfreturn false />
  </cfif>
</cffunction>

<!---                    --->
<!--- SESSION MANAGEMENT --->
<!---                    --->

<!--- EXPIRE OLD SESSIONS --->
<cffunction name="expireOldSessions" access="public" returntype="void" output="false" hint="I expire sessions that are older than the timeout period passed in.">
  <cfargument name="timeout" type="numeric" required="true" hint="I am the timeout period used to expire sessions." />
  
  <!--- var scope --->
  <cfset var qDelSessions = '' />
  
  <!--- delete sessions whose lastActionAt is older than the timeout --->
  <cfquery name="qDelSessions" datasource="#variables.datasource#">
    DELETE FROM merchtool.Session
    WHERE lastActionAt < <cfqueryparam value="#DateAdd('n',-ARGUMENTS.timeout,Now())#" cfsqltype="cf_sql_timestamp" />
  </cfquery>
  
</cffunction>

<!--- IS VALID SESSION --->
<cffunction name="isValidSession" access="public" returntype="boolean" output="false" hint="I validate a session exists in the database.">
  <cfargument name="encId" type="string" required="true" hint="I am the encrypted session id returned from the cookie." />
  
  <!--- var scope --->
  <cfset var qGetSession = '' />
  <cfset var sid = APPLICATION.utils.dataDec(ARGUMENTS.encId, 'cookie') />
  
  <!--- get the session from the database --->
  <cfquery name="qGetSession" datasource="#variables.datasource#">
    SELECT uniqueId
    FROM merchtool.Session
    WHERE sessionId = <cfqueryparam value="#Hash(sid,'SHA-512')#" cfsqltype="cf_sql_varchar" />
  </cfquery>
  
  <!--- check if the session exists (record returned) --->
  <cfif qGetSession.RecordCount>
    <!--- session exists, return true --->
    <cfreturn true />
  <!--- otherwise --->
  <cfelse>
    <!--- session does not exist, return false --->
    <cfreturn false />
  </cfif>
    
</cffunction>

<!--- GET USER ID FROM SESSION --->
<cffunction name="getUserIdFromSession" access="public" returntype="boolean" output="false" hint="I return the user id stored with the session.">
  <cfargument name="encId" type="string" required="true" hint="I am the encrypted session id returned from the cookie." />
  
  <!--- var scope --->
  <cfset var qGetSession = '' />
  <cfset var sid = APPLICATION.utils.dataDec(ARGUMENTS.encId, 'cookie') />
  
  <!--- get the session from the database --->
  <cfquery name="qGetSession" datasource="#variables.datasource#">
    SELECT userId
    FROM merchtool.Session
    WHERE sessionId = <cfqueryparam value="#Hash(sid,'SHA-512')#" cfsqltype="cf_sql_varchar" />
  </cfquery>
  
  <!--- return the user id from the session --->
  <cfreturn qGetSession.userId />
    
</cffunction>

<!--- EXPIRE SESSION --->
<cffunction name="expireSession" access="public" returntype="void" output="false" hint="I expire a session based on the id passed in.">
  <cfargument name="encId" type="string" required="true" hint="I am the encrypted session id returned from the cookie." />
  
  <!--- var scope --->
  <cfset var qDelSession = '' />
  <cfset var sid = APPLICATION.utils.dataDec(ARGUMENTS.encId, 'cookie') />
  
  <!--- delete session by session id --->
  <cfquery name="qDelSession" datasource="#variables.datasource#">
    DELETE FROM merchtool.Session
    WHERE sessionId = <cfqueryparam value="#Hash(sid,'SHA-512')#" cfsqltype="cf_sql_varchar" />
  </cfquery>
  
</cffunction>

<!--- ADD SESSION --->
<cffunction name="addSession" access="public" returntype="void" output="false" hint="I add a new session to the database.">
  <cfargument name="sessionId" type="string" required="true" hint="I am the unencrypted session id generated for this session." />
  <cfargument name="user" type="any" required="true" hint="I am the user object for the user this session is beging added for." />

  <!--- var scope --->
  <cfset var qAddSession = '' />
  
  <!--- add the session --->
  <cfquery name="qAddSession" datasource="#variables.datasource#">
    INSERT INTO merchtool.Session
      (
      sessionId,
      userId,
      lastActionAt
      ) VALUES (
      <cfqueryparam value="#Hash(ARGUMENTS.sessionId,'SHA-512')#" cfsqltype="cf_sql_varchar" />,
      <cfqueryparam value="#ARGUMENTS.user.getUserId()#" cfsqltype="cf_sql_integer" />,
      <cfqueryparam value="#Now()#" cfsqltype="cf_sql_timestamp" />
      )
  </cfquery>

</cffunction>

</cfcomponent>

